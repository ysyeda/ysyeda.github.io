<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta property="og:image" content="https://og-image.now.sh/Moaaz%20Sidat.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Moaaz Sidat"/><meta name="twitter:card" content="summary_large_image"/><title>Super-charging React with ImmutableJS</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/ba86c1ab63e9ebce3ca5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ba86c1ab63e9ebce3ca5.css" data-n-g=""/><link rel="preload" href="/_next/static/css/41fa89398edfb7317e86.css" as="style"/><link rel="stylesheet" href="/_next/static/css/41fa89398edfb7317e86.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-f094e29a130fd0913879.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.286c5ad94e4334e87283.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-81319c1e98dc43a10e5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/3b811ef4b719e878676e86b8ca0698881498d299.39adbbb4847b4d534806.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/writings/%5Bid%5D-7debc0b3d2907aea7d4d.js" as="script"/></head><body><div id="__next"><div class="layout_outerContainer__paSMS"><div class="layout_container__2t4v2"><main><article><h1 class="utils_headingXl__1XecN">Super-charging React with ImmutableJS</h1><div class="utils_lightText__12Ckm"><time dateTime="2015-11-24">November 24, 2015</time></div><div><p>At Hootsuite, we’ve been working on restructuring our front-end architecture using React and Flux. This has given us the opportunity to explore the benefits we gains by structuring the data on the front-end as immutable collections. As part of the Engagement team, a group of us are working on Streams, the part of the product our users directly interact with when they use the Hootsuite dashboard. This is one of the major chunks of the product being migrated over from Backbone and jQuery.</p>
<p>For those who are new to React, it is a JavaScript library for building user interfaces, built by the folks over at Facebook and Instagram to enable them to build large web based application with data that changes over time. It is often valuable to think of React as the view part of the Model-View-Controller pattern.</p>
<p>Flux is an architectural pattern that complements React by utilizing a uni-directional data flow. When a user interacts with a React view, the View fires an Action that goes through a Dispatcher to update a Store that holds the application’s data and state, which in turn updates the Views. Uni-directional data flow ensures that a change in application’s state is updated wherever the state is used without forcing the developer to update the code everywhere the state is used.</p>
<p><img src="/images/writings/flux.png" alt="Flux Architecture" title="Flux Architecture"></p>
<div class="caption">Source: Flux Overview (https://facebook.github.io/flux/docs/overview.html)</div>
<p>You can learn more about React and Flux by reading this <a href="http://code.hootsuite.com/hootsuite-react-and-flux/">in-depth post</a> written by my teammate, <a href="https://twitter.com/catherinettt">Catherine</a>.</p>
<h3>Making React Even Faster</h3>
<p>As part of building out our new front-end, it was important that performance was a concern that we kept in mind. With customers relying on our product to be highly efficient and robust, this was going to be a primary concern as we moved over to React and Flux. A key improvement metric that can be looked into with regards to React is how often a component re-renders. That’s where immutable data comes into play and provides a better way to optimize the process of re-rendering.</p>
<p>The way React works is by maintaining its own fast implementation of the DOM tree called the virtual DOM. Whenever there is a change in the UI, React makes a new virtual DOM and compares it with the old one, and if they’re different, it updates the actual DOM, minimizing the number of mutations. To improve performance, we need to ensure that only the part affected by the changes in the data is re-rendered. To allow developers to do this, React provides a component lifecycle function called <code>shouldComponentUpdate</code> which runs every time a component is re-rendered. We can couple this function with immutable data structures to ensure that a re-render only happens when the data has actually changed.</p>
<h3>The Problem with Mutable collections</h3>
<p>Let’s look at some of the problems that we may run into if incase we were dealing with mutable data and states within React. Imagine a Message component that takes the data necessary to render a message on the page. If a user was to edit the message text, we want to ensure that the component reflects the change, so we might have something like this in our lifecycle function that allows us to re-render only if the message text has changed when we receive a new list of messages.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Message Component</span>
<span class="hljs-attr">shouldComponentUpdate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newProps, newState</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.text !== newProps.text;
}</code></pre>
<p>However, with large and complex data structures this becomes an issue because we’re passing around pieces of the the application’s state as Objects and an identity (triple equal) comparison fails for Object in Javascript, even if the values are the same across both:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> obj1 = { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> };
<span class="hljs-keyword">var</span> obj2 = { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> };
obj1 === obj2; <span class="hljs-comment">// false because obj1 &#x26; obj2 are different objects, even if values are the same</span></code></pre>
<p>Instead, we need to do a deep comparison to determine whether the values we’ve received have actually changed. However, with nested objects, we would need to do a recursive deep comparison operation that is really expensive. And since such a comparison would need to be done every time <code>shouldComponentUpdate</code> runs, which React invokes very frequently, we would take a large performance hit.</p>
<p>Yet another problem we run into with JavaScript objects are references to the same object returning true when compared even if the values are changed like so:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Same reference</span>
<span class="hljs-keyword">var</span> x = { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> };
<span class="hljs-keyword">var</span> y = x;
y.foo = <span class="hljs-string">'qux'</span>;
x.foo; <span class="hljs-comment">// 'qux', because x has also changed</span>
x === y; <span class="hljs-comment">// true even though 'apparently', value was changed</span></code></pre>
<h3>ImmutableJS to the Rescue</h3>
<p>We can solve these problems with immutable data. ImmutableJS is a JavaScript library that provides immutable collections which provide two important guarantees. The first being that once an immutable collection is created, it cannot be changed. And the second being that a new collection can be created from an existing one by mutating the original one. Moreover, any changes to a collection results in a new one being made. This avoids any false truthy values arising from comparisons of objects that may have the same reference.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> Immutable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'immutable'</span>);
<span class="hljs-keyword">var</span> x = Immutable.Map({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> });
<span class="hljs-keyword">var</span> y = x.set(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'newbar'</span>);
x === y; <span class="hljs-comment">// false, as required since value at foo has changed</span>
<span class="hljs-keyword">var</span> z = x.set(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>);
x === z; <span class="hljs-comment">// true, as required since value at foo has not changed</span></code></pre>
<p>What does that mean if you’re using Flux stores to manage the data as a state of the UI? Well, it means that the data within the Flux stores will need to be modelled to be immutable. With the state of our UI being immutable data, we gain the ability to perform very fast comparisons. This allows us to use such comparisons within the <code>shouldComponentUpdate</code> without negatively affecting the performance.</p>
<h3>Shared Structure</h3>
<p>One way that immutable collections achieve space and time efficiency is through sharing structure. Whenever a new collection is made from a new one, it reuses the parts that haven’t changed, and only creates the parts that are new, or have changed. This avoids the time lost spent copying an entire structure, making it time efficient. Moreover, the memory footprint is also smaller since the same parts are being used for this new structure. We can illustrate this through the following example of a tree structure where a we’re updating a node.</p>
<p>When we need to make changes to the blue node, we create a copy of it, marked by the orange one. It can still point to its old child since we don’t need to change that. However, the parent of the blue node needs to point to the new one, so we need to create a copy of it, marked by the red node, and point to the copy of the blue node, however, we can still reuse the parent’s left child. Notice how more than 50% of the structure is being shared.</p>
<p><img src="/images/writings/01-SharedStructure.gif" alt="Shared Structure" title="Shared Structure"></p>
<h3>Arrays and Objects as Immutable collections</h3>
<p>Now that’s pretty cool but what about Arrays and Objects? Arrays, which are a list of values, and Objects, which are key value pairs are the bread and butter of our modern applications. Immutable provides two highly efficient implementations of these two data structures. Arrays are represented by Bitmapped Vector Tries, whereas Objects are represented by Hash Array Mapped Tries. Let’s take a look at what these two are and how they work.</p>
<p>Bitmapped Array Tries can be imagined as a tree of arrays. All the actual values are only stored in the leaves. In the example below, let’s say we wish to find the value ‘114′. First, we’ll convert the number to a binary. This gives us 01110010. We lookup the first two most significant bits. We get 01, which is the number 1, so we follow along index 1 of our first array. Next we lookup the next two significant bits and we get 11. That’s the number 3, so we we follow along the index 3 of our next array. Then we lookup 00, which corresponds to index 0. And lastly, we lookup 10, which corresponds to index 2. And voila! We’ve found our value ‘114′. If in case we wanted to store something at value ‘114′, say a string ‘foo’, we’d lookup value using the algorithm described and place the value in the 114th place. This implementation is used by the immutable collection called List and can be used as an Array.</p>
<p><img src="/images/writings/02-BitmappedArrayTrie.gif" alt="Bitmapped Array Trie" title="Bitmapped Array Trie"></p>
<p>Hash Mapped Array Tries work in a similar fashion, the keys and their corresponding values are only stored at the leaf nodes of the tree. If we wish to find a value associated to the key ‘m’, we first pass the key through a hash function. A hash function can be thought of a function that takes anything and returns a number. Let’s say that for ‘m’, our hash function gives us the value 45. We convert 45 to binary, and this time, instead of looking up the most significant bits, we lookup the two least significant bits first. Which, in this case, are 01. We go follow through to index 1, we lookup the next two least significant bits, which are 11, so we follow through to index 4. Then we lookup 10, which corresponds to index 10. And ta-da! We’ve found the key ‘m’. We lookup the value and return ‘munchkin’. A hash array mapped trie has the ability to increase its dynamically, unlike a conventional hash map. This makes dealing with collisions (adding two values to the same node) significantly less expensive. This implementation is used by the immutable collection called Map and can be used as an Array.</p>
<p><img src="/images/writings/03-HashMappedArrayTrie.gif" alt="Hash Mapped Array Trie" title="Hash Mapped Array Trie"></p>
<h3>In Conclusion</h3>
<p>How is all of this useful to us as JavaScript developers? It turns out that JavaScript engines are highly optimized for dealing with bit-shift operations that the data structures used in building immutable collections rely on. This provides us with extremely fast implementations of Arrays and Objects, which are Lists and Maps respectively. Coupled with React’s ability to reconcile the DOM tree high effectively, this allows us to do very fast comparison when the state of our application changes, and update the UI in a manner where anything that hasn’t changed, does not effectively re-render.
By doing so, we are able to optimize the rendering process to a point where we’re only re-rendering only the things that have truly changed in the application state, which is represented by the data received by our application. And with that, we are able to take React, one of the fastest libraries we have for building user interfaces, and make it even faster.</p>
<p>My heartiest thanks to <a href="https://twitter.com/theasta">Alexandrine</a> and <a href="https://twitter.com/noelpullen">Noel</a> for their feedback on this write up.</p>
<h4>References &#x26; Additional Reading</h4>
<ul>
<li>David Nolen – <a href="https://www.youtube.com/watch?v=mS264h8KGwk">Immutability, interactivity &#x26; Javascript (FutureJS 2014)</a></li>
<li>Lee Byron – <a href="https://www.youtube.com/watch?v=I7IdS-PbEgI">Immutable Data and React (React.js Conf 2015)</a></li>
<li>Jean Niklas L’Orange – <a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">Understanding Clojure’s Persistent Vectors (Part 1)</a></li>
<li>Phil Bagwell – <a href="http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf">Ideal Hash Trees</a></li>
</ul>
<p><span class="note">The resources above were essential towards helping me understand immutable collections and their implementation details described in the GIF illustrations above. The illustrations of the tree structures were drawn in Sketch and then converted to a GIF using Photoshop.</span></p>
<p class="endnote">This article was originally written for and posted on the <a href="http://code.hootsuite.com/super-charging-react-with-immutablejs/"/>Hootsuite Engineering Blog</a></p>
</div></article></main><div class="layout_backToHome__1vZsp"><a href="/">← Home</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"2015-11-24-supercharging-react-with-immutablejs.md","contentHtml":"\u003cp\u003eAt Hootsuite, we’ve been working on restructuring our front-end architecture using React and Flux. This has given us the opportunity to explore the benefits we gains by structuring the data on the front-end as immutable collections. As part of the Engagement team, a group of us are working on Streams, the part of the product our users directly interact with when they use the Hootsuite dashboard. This is one of the major chunks of the product being migrated over from Backbone and jQuery.\u003c/p\u003e\n\u003cp\u003eFor those who are new to React, it is a JavaScript library for building user interfaces, built by the folks over at Facebook and Instagram to enable them to build large web based application with data that changes over time. It is often valuable to think of React as the view part of the Model-View-Controller pattern.\u003c/p\u003e\n\u003cp\u003eFlux is an architectural pattern that complements React by utilizing a uni-directional data flow. When a user interacts with a React view, the View fires an Action that goes through a Dispatcher to update a Store that holds the application’s data and state, which in turn updates the Views. Uni-directional data flow ensures that a change in application’s state is updated wherever the state is used without forcing the developer to update the code everywhere the state is used.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/writings/flux.png\" alt=\"Flux Architecture\" title=\"Flux Architecture\"\u003e\u003c/p\u003e\n\u003cdiv class=\"caption\"\u003eSource: Flux Overview (https://facebook.github.io/flux/docs/overview.html)\u003c/div\u003e\n\u003cp\u003eYou can learn more about React and Flux by reading this \u003ca href=\"http://code.hootsuite.com/hootsuite-react-and-flux/\"\u003ein-depth post\u003c/a\u003e written by my teammate, \u003ca href=\"https://twitter.com/catherinettt\"\u003eCatherine\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eMaking React Even Faster\u003c/h3\u003e\n\u003cp\u003eAs part of building out our new front-end, it was important that performance was a concern that we kept in mind. With customers relying on our product to be highly efficient and robust, this was going to be a primary concern as we moved over to React and Flux. A key improvement metric that can be looked into with regards to React is how often a component re-renders. That’s where immutable data comes into play and provides a better way to optimize the process of re-rendering.\u003c/p\u003e\n\u003cp\u003eThe way React works is by maintaining its own fast implementation of the DOM tree called the virtual DOM. Whenever there is a change in the UI, React makes a new virtual DOM and compares it with the old one, and if they’re different, it updates the actual DOM, minimizing the number of mutations. To improve performance, we need to ensure that only the part affected by the changes in the data is re-rendered. To allow developers to do this, React provides a component lifecycle function called \u003ccode\u003eshouldComponentUpdate\u003c/code\u003e which runs every time a component is re-rendered. We can couple this function with immutable data structures to ensure that a re-render only happens when the data has actually changed.\u003c/p\u003e\n\u003ch3\u003eThe Problem with Mutable collections\u003c/h3\u003e\n\u003cp\u003eLet’s look at some of the problems that we may run into if incase we were dealing with mutable data and states within React. Imagine a Message component that takes the data necessary to render a message on the page. If a user was to edit the message text, we want to ensure that the component reflects the change, so we might have something like this in our lifecycle function that allows us to re-render only if the message text has changed when we receive a new list of messages.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Message Component\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eshouldComponentUpdate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enewProps, newState\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.props.text !== newProps.text;\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, with large and complex data structures this becomes an issue because we’re passing around pieces of the the application’s state as Objects and an identity (triple equal) comparison fails for Object in Javascript, even if the values are the same across both:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e obj1 = { \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e obj2 = { \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e };\nobj1 === obj2; \u003cspan class=\"hljs-comment\"\u003e// false because obj1 \u0026#x26; obj2 are different objects, even if values are the same\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInstead, we need to do a deep comparison to determine whether the values we’ve received have actually changed. However, with nested objects, we would need to do a recursive deep comparison operation that is really expensive. And since such a comparison would need to be done every time \u003ccode\u003eshouldComponentUpdate\u003c/code\u003e runs, which React invokes very frequently, we would take a large performance hit.\u003c/p\u003e\n\u003cp\u003eYet another problem we run into with JavaScript objects are references to the same object returning true when compared even if the values are changed like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Same reference\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = { \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e y = x;\ny.foo = \u003cspan class=\"hljs-string\"\u003e'qux'\u003c/span\u003e;\nx.foo; \u003cspan class=\"hljs-comment\"\u003e// 'qux', because x has also changed\u003c/span\u003e\nx === y; \u003cspan class=\"hljs-comment\"\u003e// true even though 'apparently', value was changed\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eImmutableJS to the Rescue\u003c/h3\u003e\n\u003cp\u003eWe can solve these problems with immutable data. ImmutableJS is a JavaScript library that provides immutable collections which provide two important guarantees. The first being that once an immutable collection is created, it cannot be changed. And the second being that a new collection can be created from an existing one by mutating the original one. Moreover, any changes to a collection results in a new one being made. This avoids any false truthy values arising from comparisons of objects that may have the same reference.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e Immutable = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'immutable'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = Immutable.Map({ \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e });\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e y = x.set(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'newbar'\u003c/span\u003e);\nx === y; \u003cspan class=\"hljs-comment\"\u003e// false, as required since value at foo has changed\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e z = x.set(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e);\nx === z; \u003cspan class=\"hljs-comment\"\u003e// true, as required since value at foo has not changed\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat does that mean if you’re using Flux stores to manage the data as a state of the UI? Well, it means that the data within the Flux stores will need to be modelled to be immutable. With the state of our UI being immutable data, we gain the ability to perform very fast comparisons. This allows us to use such comparisons within the \u003ccode\u003eshouldComponentUpdate\u003c/code\u003e without negatively affecting the performance.\u003c/p\u003e\n\u003ch3\u003eShared Structure\u003c/h3\u003e\n\u003cp\u003eOne way that immutable collections achieve space and time efficiency is through sharing structure. Whenever a new collection is made from a new one, it reuses the parts that haven’t changed, and only creates the parts that are new, or have changed. This avoids the time lost spent copying an entire structure, making it time efficient. Moreover, the memory footprint is also smaller since the same parts are being used for this new structure. We can illustrate this through the following example of a tree structure where a we’re updating a node.\u003c/p\u003e\n\u003cp\u003eWhen we need to make changes to the blue node, we create a copy of it, marked by the orange one. It can still point to its old child since we don’t need to change that. However, the parent of the blue node needs to point to the new one, so we need to create a copy of it, marked by the red node, and point to the copy of the blue node, however, we can still reuse the parent’s left child. Notice how more than 50% of the structure is being shared.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/writings/01-SharedStructure.gif\" alt=\"Shared Structure\" title=\"Shared Structure\"\u003e\u003c/p\u003e\n\u003ch3\u003eArrays and Objects as Immutable collections\u003c/h3\u003e\n\u003cp\u003eNow that’s pretty cool but what about Arrays and Objects? Arrays, which are a list of values, and Objects, which are key value pairs are the bread and butter of our modern applications. Immutable provides two highly efficient implementations of these two data structures. Arrays are represented by Bitmapped Vector Tries, whereas Objects are represented by Hash Array Mapped Tries. Let’s take a look at what these two are and how they work.\u003c/p\u003e\n\u003cp\u003eBitmapped Array Tries can be imagined as a tree of arrays. All the actual values are only stored in the leaves. In the example below, let’s say we wish to find the value ‘114′. First, we’ll convert the number to a binary. This gives us 01110010. We lookup the first two most significant bits. We get 01, which is the number 1, so we follow along index 1 of our first array. Next we lookup the next two significant bits and we get 11. That’s the number 3, so we we follow along the index 3 of our next array. Then we lookup 00, which corresponds to index 0. And lastly, we lookup 10, which corresponds to index 2. And voila! We’ve found our value ‘114′. If in case we wanted to store something at value ‘114′, say a string ‘foo’, we’d lookup value using the algorithm described and place the value in the 114th place. This implementation is used by the immutable collection called List and can be used as an Array.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/writings/02-BitmappedArrayTrie.gif\" alt=\"Bitmapped Array Trie\" title=\"Bitmapped Array Trie\"\u003e\u003c/p\u003e\n\u003cp\u003eHash Mapped Array Tries work in a similar fashion, the keys and their corresponding values are only stored at the leaf nodes of the tree. If we wish to find a value associated to the key ‘m’, we first pass the key through a hash function. A hash function can be thought of a function that takes anything and returns a number. Let’s say that for ‘m’, our hash function gives us the value 45. We convert 45 to binary, and this time, instead of looking up the most significant bits, we lookup the two least significant bits first. Which, in this case, are 01. We go follow through to index 1, we lookup the next two least significant bits, which are 11, so we follow through to index 4. Then we lookup 10, which corresponds to index 10. And ta-da! We’ve found the key ‘m’. We lookup the value and return ‘munchkin’. A hash array mapped trie has the ability to increase its dynamically, unlike a conventional hash map. This makes dealing with collisions (adding two values to the same node) significantly less expensive. This implementation is used by the immutable collection called Map and can be used as an Array.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/writings/03-HashMappedArrayTrie.gif\" alt=\"Hash Mapped Array Trie\" title=\"Hash Mapped Array Trie\"\u003e\u003c/p\u003e\n\u003ch3\u003eIn Conclusion\u003c/h3\u003e\n\u003cp\u003eHow is all of this useful to us as JavaScript developers? It turns out that JavaScript engines are highly optimized for dealing with bit-shift operations that the data structures used in building immutable collections rely on. This provides us with extremely fast implementations of Arrays and Objects, which are Lists and Maps respectively. Coupled with React’s ability to reconcile the DOM tree high effectively, this allows us to do very fast comparison when the state of our application changes, and update the UI in a manner where anything that hasn’t changed, does not effectively re-render.\nBy doing so, we are able to optimize the rendering process to a point where we’re only re-rendering only the things that have truly changed in the application state, which is represented by the data received by our application. And with that, we are able to take React, one of the fastest libraries we have for building user interfaces, and make it even faster.\u003c/p\u003e\n\u003cp\u003eMy heartiest thanks to \u003ca href=\"https://twitter.com/theasta\"\u003eAlexandrine\u003c/a\u003e and \u003ca href=\"https://twitter.com/noelpullen\"\u003eNoel\u003c/a\u003e for their feedback on this write up.\u003c/p\u003e\n\u003ch4\u003eReferences \u0026#x26; Additional Reading\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eDavid Nolen – \u003ca href=\"https://www.youtube.com/watch?v=mS264h8KGwk\"\u003eImmutability, interactivity \u0026#x26; Javascript (FutureJS 2014)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLee Byron – \u003ca href=\"https://www.youtube.com/watch?v=I7IdS-PbEgI\"\u003eImmutable Data and React (React.js Conf 2015)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eJean Niklas L’Orange – \u003ca href=\"http://hypirion.com/musings/understanding-persistent-vector-pt-1\"\u003eUnderstanding Clojure’s Persistent Vectors (Part 1)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePhil Bagwell – \u003ca href=\"http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf\"\u003eIdeal Hash Trees\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cspan class=\"note\"\u003eThe resources above were essential towards helping me understand immutable collections and their implementation details described in the GIF illustrations above. The illustrations of the tree structures were drawn in Sketch and then converted to a GIF using Photoshop.\u003c/span\u003e\u003c/p\u003e\n\u003cp class=\"endnote\"\u003eThis article was originally written for and posted on the \u003ca href=\"http://code.hootsuite.com/super-charging-react-with-immutablejs/\"/\u003eHootsuite Engineering Blog\u003c/a\u003e\u003c/p\u003e\n","layout":"post","title":"Super-charging React with ImmutableJS","date":"2015-11-24","categories":"writings"}},"__N_SSG":true},"page":"/writings/[id]","query":{"id":"2015-11-24-supercharging-react-with-immutablejs.md"},"buildId":"mBKy1n304Vu_wql3ukrxN","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-86038f8325ecf14c2308.js"></script><script src="/_next/static/chunks/main-f094e29a130fd0913879.js" async=""></script><script src="/_next/static/chunks/webpack-95c2b224bccf352ee870.js" async=""></script><script src="/_next/static/chunks/framework.492e6181467ebf2e0a6c.js" async=""></script><script src="/_next/static/chunks/commons.286c5ad94e4334e87283.js" async=""></script><script src="/_next/static/chunks/pages/_app-81319c1e98dc43a10e5b.js" async=""></script><script src="/_next/static/chunks/3b811ef4b719e878676e86b8ca0698881498d299.39adbbb4847b4d534806.js" async=""></script><script src="/_next/static/chunks/pages/writings/%5Bid%5D-7debc0b3d2907aea7d4d.js" async=""></script><script src="/_next/static/mBKy1n304Vu_wql3ukrxN/_buildManifest.js" async=""></script><script src="/_next/static/mBKy1n304Vu_wql3ukrxN/_ssgManifest.js" async=""></script></body></html>